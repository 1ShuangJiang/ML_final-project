{
  "run_id": "20251028_220436",
  "llm_name": "DeepSeek(deepseek-chat)",
  "n_samples": 30,
  "n_queries_per_sample": null,
  "query_multiplier": 1.0,
  "seed": 33550336,
  "timestamp": "2025-10-29T01:06:40.568562",
  "results": [
    {
      "observation_set_id": "n3_inputs_01_10_11_outputs_001",
      "n_observations": 3,
      "n_ground_truths": 2,
      "n_queries": 2,
      "roll_k": 5,
      "n_valid": 8,
      "n_unique_valid": 1,
      "n_unique_all": 1,
      "n_recovered_gts": 1,
      "parse_success_rate": 1.0,
      "in_space_rate": 0.8,
      "valid_rate": 0.8,
      "novelty_rate": 0.1,
      "recovery_rate": 0.5,
      "all_hypotheses": [
        "x AND y",
        "x AND y",
        "x AND y",
        "(x AND y) OR (NOT x AND NOT y) \u2014 but NOT is not allowed, so invalid.",
        "x \u2261 y = (x AND y) OR (NOT x AND NOT y). But we can't use NOT. So impossible with only AND/OR? Let's check: With only AND/OR, the only functions possible are monotone Boolean functions (closed under 0\u21921 in input). f(0,0)=1 and f(0,1)=0 violates monotonicity (increasing y from 0 to 1 should not decrease output from 1 to 0). So indeed, f(0,0) cannot be 1 with only AND/OR. So only possible truth table is 0001",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y"
      ],
      "valid_hypotheses": [
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y"
      ],
      "unique_valid_expressions": [
        "x AND y"
      ],
      "unique_all_expressions": [
        "x AND y"
      ],
      "token_usage": {
        "prompt_tokens": 11005,
        "completion_tokens": 5131,
        "total_tokens": 16136
      },
      "cost": 0.0029773800000000004,
      "errors": [],
      "error_summary": {
        "total_errors": 0,
        "error_types": {}
      }
    },
    {
      "observation_set_id": "n4_inputs_00_01_10_11_outputs_0101",
      "n_observations": 4,
      "n_ground_truths": 3,
      "n_queries": 3,
      "roll_k": 5,
      "n_valid": 14,
      "n_unique_valid": 2,
      "n_unique_all": 2,
      "n_recovered_gts": 2,
      "parse_success_rate": 1.0,
      "in_space_rate": 0.9333333333333333,
      "valid_rate": 0.9333333333333333,
      "novelty_rate": 0.13333333333333333,
      "recovery_rate": 0.6666666666666666,
      "all_hypotheses": [
        "(x OR y) AND y",
        "\", then after list, \"MechanisticKey: \" with the keys, then \"ReverseCheck: \"",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y"
      ],
      "valid_hypotheses": [
        "(x OR y) AND y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y"
      ],
      "unique_valid_expressions": [
        "(x OR y) AND y",
        "y"
      ],
      "unique_all_expressions": [
        "(x OR y) AND y",
        "y"
      ],
      "token_usage": {
        "prompt_tokens": 15930,
        "completion_tokens": 7153,
        "total_tokens": 23083
      },
      "cost": 0.0042330399999999995,
      "errors": [],
      "error_summary": {
        "total_errors": 0,
        "error_types": {}
      }
    },
    {
      "observation_set_id": "n2_inputs_01_10_outputs_11",
      "n_observations": 2,
      "n_ground_truths": 2,
      "n_queries": 2,
      "roll_k": 5,
      "n_valid": 7,
      "n_unique_valid": 1,
      "n_unique_all": 1,
      "n_recovered_gts": 1,
      "parse_success_rate": 1.0,
      "in_space_rate": 0.7,
      "valid_rate": 0.7,
      "novelty_rate": 0.1,
      "recovery_rate": 0.5,
      "all_hypotheses": [
        "x OR y",
        "(x AND NOT y) OR (NOT x AND y) but we can't use NOT. With only AND/OR, we can't express XOR. Wait, let's check: We need f(0,0)=0, f(0,1)=1, f(1,0)=1, f(1,1)=0. With only AND/OR, impossible without NOT. So discard",
        "(x OR y) AND NOT (x AND y) - but NOT is not allowed, so need alternative",
        "x OR y",
        "x OR y",
        "x OR y",
        "x OR y",
        "x OR y gives f(0,0)=0, f(0,1)=1, f(1,0)=1, f(1,1)=1 \u2192 not matching (1,1)=0.",
        "x OR y",
        "x OR y"
      ],
      "valid_hypotheses": [
        "x OR y",
        "x OR y",
        "x OR y",
        "x OR y",
        "x OR y",
        "x OR y",
        "x OR y"
      ],
      "unique_valid_expressions": [
        "x OR y"
      ],
      "unique_all_expressions": [
        "x OR y"
      ],
      "token_usage": {
        "prompt_tokens": 10660,
        "completion_tokens": 14517,
        "total_tokens": 25177
      },
      "cost": 0.005557160000000001,
      "errors": [],
      "error_summary": {
        "total_errors": 0,
        "error_types": {}
      }
    },
    {
      "observation_set_id": "n4_inputs_00_01_10_11_outputs_0011",
      "n_observations": 4,
      "n_ground_truths": 3,
      "n_queries": 3,
      "roll_k": 5,
      "n_valid": 15,
      "n_unique_valid": 1,
      "n_unique_all": 1,
      "n_recovered_gts": 1,
      "parse_success_rate": 1.0,
      "in_space_rate": 1.0,
      "valid_rate": 1.0,
      "novelty_rate": 0.06666666666666667,
      "recovery_rate": 0.3333333333333333,
      "all_hypotheses": [
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x"
      ],
      "valid_hypotheses": [
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x"
      ],
      "unique_valid_expressions": [
        "x"
      ],
      "unique_all_expressions": [
        "x"
      ],
      "token_usage": {
        "prompt_tokens": 15670,
        "completion_tokens": 1630,
        "total_tokens": 17300
      },
      "cost": 0.0026502,
      "errors": [],
      "error_summary": {
        "total_errors": 0,
        "error_types": {}
      }
    },
    {
      "observation_set_id": "n1_inputs_01_outputs_1",
      "n_observations": 1,
      "n_ground_truths": 5,
      "n_queries": 5,
      "roll_k": 5,
      "n_valid": 19,
      "n_unique_valid": 2,
      "n_unique_all": 2,
      "n_recovered_gts": 2,
      "parse_success_rate": 1.0,
      "in_space_rate": 0.76,
      "valid_rate": 0.76,
      "novelty_rate": 0.08,
      "recovery_rate": 0.4,
      "all_hypotheses": [
        "y",
        "(NOT x) AND y, but NOT is not allowed. So we can't express this without NOT. So impossible with only AND, OR. Discard",
        "y",
        "x OR y",
        "y AND NOT x \u2014 but NOT is not allowed, so discard",
        "y",
        "y",
        "(NOT x) AND y \u2014 but NOT is not allowed. With only AND, OR, we can't express this. Discard",
        "y",
        "y \u2192 truth table: (0,0)=0, (0,1)=1, (1,0)=0, (1,1)=1 \u2192 matches (0,1)=1, others unknown? Actually, for (0,1)=1, it's fine. But we need all observations? Only one given, so it's consistent",
        "y",
        "(NOT x) AND y, but NOT is not allowed. With only AND, OR, we can't express this. So discard",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "(NOT x) AND y, but NOT is not allowed. With only AND, OR, we cannot express this",
        "y"
      ],
      "valid_hypotheses": [
        "y",
        "y",
        "x OR y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y",
        "y"
      ],
      "unique_valid_expressions": [
        "y",
        "x OR y"
      ],
      "unique_all_expressions": [
        "y",
        "x OR y"
      ],
      "token_usage": {
        "prompt_tokens": 28325,
        "completion_tokens": 32834,
        "total_tokens": 61159
      },
      "cost": 0.013159019999999999,
      "errors": [],
      "error_summary": {
        "total_errors": 0,
        "error_types": {
          "unknown_error": 1
        }
      }
    },
    {
      "observation_set_id": "n2_inputs_10_11_outputs_01",
      "n_observations": 2,
      "n_ground_truths": 5,
      "n_queries": 5,
      "roll_k": 5,
      "n_valid": 21,
      "n_unique_valid": 2,
      "n_unique_all": 2,
      "n_recovered_gts": 2,
      "parse_success_rate": 1.0,
      "in_space_rate": 0.84,
      "valid_rate": 0.84,
      "novelty_rate": 0.08,
      "recovery_rate": 0.4,
      "all_hypotheses": [
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "For (0,0)\u21921, (0,1)\u21920, (1,0)\u21920, (1,1)\u21921. This is x \u2194 y or x EQUALS y, but we only have AND, OR. With AND, OR, this is (x AND y) OR (NOT x AND NOT y), but NOT is not allowed. So, impossible with only AND, OR? Wait, check: We can't use NOT, so we can't express this function with only AND, OR? Actually, with only AND, OR, the functions are monotonic (if inputs increase, output doesn't decrease). Here, from (0,0)\u21921 to (0,1)\u21920, y increased but output decreased, so not monotonic. So, this truth table is impossible with only AND, OR. So, discard",
        "y",
        "(x AND y) OR (NOT x AND NOT y) but we can't use NOT. Actually, we can't implement XNOR with only AND/OR without NOT, so this truth-table is impossible with our operators. Let me check: We need an expression that gives 1 when x=y and 0 when x\u2260y, using only AND/OR. This is impossible because AND/OR are monotonic (if we change an input from 0 to 1, output can't decrease), but XNOR is not monotonic (changing from (0,0) to (0,1) changes output from 1 to 0). So truth-table 3 is impossible",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "We need output 1 for (0,0), (0,1), (1,1) and 0 for (1,0). This is NOT x OR y? But NOT is not allowed. With only AND, OR, we can try: (y) OR (something with x). If we take y OR (x AND something), but for (1,0) we need 0, so if y=0, then x AND something must be 0. For (0,0), we need 1, but y=0, so we need something that gives 1 when x=0. That would require a constant or NOT x, but constants and NOT are not allowed. So, this truth table is also impossible with only AND, OR",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "AND(x,y) MechanisticKey: ('AND', (('VAR', 'x'), ('VAR', 'y')))"
      ],
      "valid_hypotheses": [
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y"
      ],
      "unique_valid_expressions": [
        "x AND y",
        "y"
      ],
      "unique_all_expressions": [
        "x AND y",
        "y"
      ],
      "token_usage": {
        "prompt_tokens": 31875,
        "completion_tokens": 19747,
        "total_tokens": 51622
      },
      "cost": 0.00999166,
      "errors": [],
      "error_summary": {
        "total_errors": 0,
        "error_types": {}
      }
    },
    {
      "observation_set_id": "n2_inputs_00_10_outputs_01",
      "n_observations": 2,
      "n_ground_truths": 5,
      "n_queries": 5,
      "roll_k": 5,
      "n_valid": 21,
      "n_unique_valid": 2,
      "n_unique_all": 2,
      "n_recovered_gts": 2,
      "parse_success_rate": 1.0,
      "in_space_rate": 0.84,
      "valid_rate": 0.84,
      "novelty_rate": 0.08,
      "recovery_rate": 0.4,
      "all_hypotheses": [
        "x",
        "x AND NOT y \u2014 but NOT not allowed, so impossible with only AND/OR?",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x AND (NOT y) \u2014 but NOT not allowed.",
        "x",
        "x",
        "x AND (NOT y) is not allowed. Let's try: x AND (x OR y) = x (since x=1 \u2192 1, x=0 \u2192 0) \u2014 but that gives (1,1) \u2192 1, not 0. So not possible. Actually, x AND (NOT y) is the only natural form, but NOT is disallowed. So maybe impossible with AND/OR only? Let's check: We need f(1,0)=1, f(0,0)=0, f(0,1)=0, f(1,1)=0. That's just x AND NOT y, which can't be expressed with only AND/OR without NOT. So this truth table is impossible with AND/OR only. So discard",
        "x",
        "x",
        "x",
        "x AND (x OR y)",
        "x",
        "x AND (x OR y)",
        "x",
        "x",
        "x \u2014 matches (0,0)\u21920, (1,0)\u21921, and is consistent with any y for unobserved rows",
        "x",
        "x",
        "x"
      ],
      "valid_hypotheses": [
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x AND (x OR y)",
        "x",
        "x AND (x OR y)",
        "x",
        "x",
        "x",
        "x",
        "x"
      ],
      "unique_valid_expressions": [
        "x",
        "x AND (x OR y)"
      ],
      "unique_all_expressions": [
        "x",
        "x AND (x OR y)"
      ],
      "token_usage": {
        "prompt_tokens": 28140,
        "completion_tokens": 22199,
        "total_tokens": 50339
      },
      "cost": 0.010155320000000002,
      "errors": [],
      "error_summary": {
        "total_errors": 0,
        "error_types": {}
      }
    },
    {
      "observation_set_id": "n1_inputs_11_outputs_1",
      "n_observations": 1,
      "n_ground_truths": 10,
      "n_queries": 10,
      "roll_k": 5,
      "n_valid": 47,
      "n_unique_valid": 2,
      "n_unique_all": 2,
      "n_recovered_gts": 2,
      "parse_success_rate": 1.0,
      "in_space_rate": 0.94,
      "valid_rate": 0.94,
      "novelty_rate": 0.04,
      "recovery_rate": 0.2,
      "all_hypotheses": [
        "x AND y",
        "x",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "(x AND y) OR (??? without NOT we can\u2019t represent 00\u21921 without also including 01 or 10). Actually check:",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "AND(OR(x,y), x) \u2014 depth 2",
        "x AND y",
        "\"",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x",
        "x AND y",
        "x",
        "x AND y",
        "x",
        "x AND y"
      ],
      "valid_hypotheses": [
        "x AND y",
        "x",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x",
        "x AND y",
        "x",
        "x AND y",
        "x",
        "x AND y"
      ],
      "unique_valid_expressions": [
        "x AND y",
        "x"
      ],
      "unique_all_expressions": [
        "x AND y",
        "x"
      ],
      "token_usage": {
        "prompt_tokens": 56755,
        "completion_tokens": 63386,
        "total_tokens": 120141
      },
      "cost": 0.025693780000000003,
      "errors": [],
      "error_summary": {
        "total_errors": 0,
        "error_types": {
          "unknown_error": 1
        }
      }
    },
    {
      "observation_set_id": "n1_inputs_01_outputs_0",
      "n_observations": 1,
      "n_ground_truths": 5,
      "n_queries": 5,
      "roll_k": 5,
      "n_valid": 20,
      "n_unique_valid": 2,
      "n_unique_all": 2,
      "n_recovered_gts": 2,
      "parse_success_rate": 1.0,
      "in_space_rate": 0.8,
      "valid_rate": 0.8,
      "novelty_rate": 0.08,
      "recovery_rate": 0.4,
      "all_hypotheses": [
        "x AND y.",
        "x",
        "\" prefix",
        "x",
        "x AND y",
        "x AND NOT x (but NOT not allowed) \u2192 Actually impossible without constants \u2192 This is just FALSE, but constants not allowed. So no valid expression",
        "x",
        "x AND y",
        "x AND y",
        "x AND y",
        "impossible without constants? Actually, we can\u2019t write 0 without constants. So not expressible.",
        "x AND y",
        "x",
        "x",
        "x AND y",
        "x",
        "x",
        "x AND y (but that\u2019s 0001, not 0000) \u2014 Actually, 0000 is impossible without constants? Wait, we can\u2019t get 0000 without constants because we have no NOT, no constants, so we cannot make a function that is 0 for all inputs. So 0000 is impossible",
        "x",
        "x AND y",
        "x AND y",
        "x",
        "x",
        "x",
        "x"
      ],
      "valid_hypotheses": [
        "x",
        "x",
        "x AND y",
        "x",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x",
        "x",
        "x AND y",
        "x",
        "x",
        "x",
        "x AND y",
        "x AND y",
        "x",
        "x",
        "x",
        "x"
      ],
      "unique_valid_expressions": [
        "x",
        "x AND y"
      ],
      "unique_all_expressions": [
        "x",
        "x AND y"
      ],
      "token_usage": {
        "prompt_tokens": 26915,
        "completion_tokens": 33446,
        "total_tokens": 60361
      },
      "cost": 0.013132980000000002,
      "errors": [],
      "error_summary": {
        "total_errors": 0,
        "error_types": {}
      }
    },
    {
      "observation_set_id": "n3_inputs_00_01_10_outputs_011",
      "n_observations": 3,
      "n_ground_truths": 2,
      "n_queries": 2,
      "roll_k": 5,
      "n_valid": 7,
      "n_unique_valid": 1,
      "n_unique_all": 1,
      "n_recovered_gts": 1,
      "parse_success_rate": 1.0,
      "in_space_rate": 0.7,
      "valid_rate": 0.7,
      "novelty_rate": 0.1,
      "recovery_rate": 0.5,
      "all_hypotheses": [
        "OR(x,y)",
        "x OR y",
        "x OR y",
        "x OR y",
        "x OR y",
        "x OR y",
        "OR(x,y)",
        "x OR y",
        "x OR y",
        "OR(x,y)"
      ],
      "valid_hypotheses": [
        "x OR y",
        "x OR y",
        "x OR y",
        "x OR y",
        "x OR y",
        "x OR y",
        "x OR y"
      ],
      "unique_valid_expressions": [
        "x OR y"
      ],
      "unique_all_expressions": [
        "x OR y"
      ],
      "token_usage": {
        "prompt_tokens": 10280,
        "completion_tokens": 5484,
        "total_tokens": 15764
      },
      "cost": 0.00297472,
      "errors": [],
      "error_summary": {
        "total_errors": 0,
        "error_types": {}
      }
    },
    {
      "observation_set_id": "n2_inputs_01_10_outputs_01",
      "n_observations": 2,
      "n_ground_truths": 3,
      "n_queries": 3,
      "roll_k": 5,
      "n_valid": 10,
      "n_unique_valid": 1,
      "n_unique_all": 1,
      "n_recovered_gts": 1,
      "parse_success_rate": 1.0,
      "in_space_rate": 0.6666666666666666,
      "valid_rate": 0.6666666666666666,
      "novelty_rate": 0.06666666666666667,
      "recovery_rate": 0.3333333333333333,
      "all_hypotheses": [
        "x",
        "x AND (NOT y) but NOT not allowed.",
        "x",
        "x",
        "x",
        "x AND (NOT y) but NOT is not allowed, so we need AND/OR only",
        "x AND (NOT y) not allowed. Instead, write in allowed ops:",
        "x AND (NOT y) but NOT is not allowed. Using only AND, OR, we can't directly express NOT. But we can use combinations: x AND (something). Actually, for x=1,y=0, we need output 1. For x=0,y=1, output 0. For x=0,y=0, output 0. For x=1,y=1, output 0. This is exactly x AND (NOT y). Since NOT is not allowed, we can't express this with only AND, OR without NOT. Wait, but we can use OR to simulate NOT? No, with only AND, OR, we can't express negation of a single variable without using the other variable. Let's check: We need f(0,1)=0, f(1,0)=1, f(0,0)=0, f(1,1)=0. This is x=1 AND y=0. With only AND, OR, we can write: x AND (x OR y) AND (y OR x)? No, that doesn't work. Actually, x AND (NOT y) cannot be expressed with only AND, OR without NOT or using both variables in a way that gives negation. Let's try: We want output 1 only when x=1 and y=0. With AND, OR, we can't get 1 for (1,0) and 0 for (1,1) without negation. So case (0,0) is impossible with only AND, OR",
        "x",
        "x AND (NOT y) - but NOT is not allowed",
        "x",
        "x",
        "x",
        "x",
        "x"
      ],
      "valid_hypotheses": [
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x"
      ],
      "unique_valid_expressions": [
        "x"
      ],
      "unique_all_expressions": [
        "x"
      ],
      "token_usage": {
        "prompt_tokens": 17205,
        "completion_tokens": 18094,
        "total_tokens": 35299
      },
      "cost": 0.007475020000000001,
      "errors": [],
      "error_summary": {
        "total_errors": 0,
        "error_types": {}
      }
    },
    {
      "observation_set_id": "n2_inputs_00_11_outputs_01",
      "n_observations": 2,
      "n_ground_truths": 10,
      "n_queries": 10,
      "roll_k": 5,
      "n_valid": 49,
      "n_unique_valid": 2,
      "n_unique_all": 2,
      "n_recovered_gts": 2,
      "parse_success_rate": 1.0,
      "in_space_rate": 0.98,
      "valid_rate": 0.98,
      "novelty_rate": 0.04,
      "recovery_rate": 0.2,
      "all_hypotheses": [
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "`x AND y",
        "x"
      ],
      "valid_hypotheses": [
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x"
      ],
      "unique_valid_expressions": [
        "x AND y",
        "x"
      ],
      "unique_all_expressions": [
        "x AND y",
        "x"
      ],
      "token_usage": {
        "prompt_tokens": 56760,
        "completion_tokens": 31073,
        "total_tokens": 87833
      },
      "cost": 0.016646840000000003,
      "errors": [],
      "error_summary": {
        "total_errors": 0,
        "error_types": {}
      }
    },
    {
      "observation_set_id": "n3_inputs_00_10_11_outputs_001",
      "n_observations": 3,
      "n_ground_truths": 5,
      "n_queries": 5,
      "roll_k": 5,
      "n_valid": 24,
      "n_unique_valid": 1,
      "n_unique_all": 1,
      "n_recovered_gts": 1,
      "parse_success_rate": 1.0,
      "in_space_rate": 0.96,
      "valid_rate": 0.96,
      "novelty_rate": 0.04,
      "recovery_rate": 0.2,
      "all_hypotheses": [
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "`x AND y` \u2014 (0,0)=0, (0,1)=0, (1,0)=0, (1,1)=1 \u2014 matches given 3 observations (since (0,1) assumed 0)",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y"
      ],
      "valid_hypotheses": [
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y",
        "x AND y"
      ],
      "unique_valid_expressions": [
        "x AND y"
      ],
      "unique_all_expressions": [
        "x AND y"
      ],
      "token_usage": {
        "prompt_tokens": 27270,
        "completion_tokens": 18121,
        "total_tokens": 45391
      },
      "cost": 0.00889168,
      "errors": [],
      "error_summary": {
        "total_errors": 0,
        "error_types": {}
      }
    },
    {
      "observation_set_id": "n3_inputs_01_10_11_outputs_011",
      "n_observations": 3,
      "n_ground_truths": 3,
      "n_queries": 3,
      "roll_k": 5,
      "n_valid": 13,
      "n_unique_valid": 1,
      "n_unique_all": 1,
      "n_recovered_gts": 1,
      "parse_success_rate": 1.0,
      "in_space_rate": 0.8666666666666667,
      "valid_rate": 0.8666666666666667,
      "novelty_rate": 0.06666666666666667,
      "recovery_rate": 0.3333333333333333,
      "all_hypotheses": [
        "x",
        "x",
        "x",
        "x",
        "x",
        "We can write this as (x OR y) AND (x OR NOT y) but NOT is not allowed.",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x.",
        "x",
        "x",
        "x"
      ],
      "valid_hypotheses": [
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x"
      ],
      "unique_valid_expressions": [
        "x"
      ],
      "unique_all_expressions": [
        "x"
      ],
      "token_usage": {
        "prompt_tokens": 15595,
        "completion_tokens": 19992,
        "total_tokens": 35587
      },
      "cost": 0.007781060000000001,
      "errors": [],
      "error_summary": {
        "total_errors": 0,
        "error_types": {}
      }
    }
  ],
  "total_token_usage": {
    "prompt_tokens": 352385,
    "completion_tokens": 292807,
    "total_tokens": 645192
  },
  "total_cost": 0.13131986,
  "total_errors": 0,
  "error_types": {}
}